diff -ur scip-3.0.1.orig/src/scip/cons_and.c scip-3.0.1/src/scip/cons_and.c
--- scip-3.0.1.orig/src/scip/cons_and.c	2013-02-03 19:24:24.000000000 +0900
+++ scip-3.0.1/src/scip/cons_and.c	2013-06-02 10:21:36.000000000 +0900
@@ -1061,11 +1061,13 @@
             break;
       }
 
-      /* if all operator variables are TRUE, the resultant has to be TRUE, otherwise, the resultant has to be FALSE */
+      /* if all operator variables are TRUE, the resultant has to be TRUE, otherwise, the resultant has to be FALSE;
+       * in case of an implicit integer resultant variable, we need to ensure the integrality of the solution value
+       */
       solval = SCIPgetSolVal(scip, sol, consdata->resvar);
-      assert(SCIPisFeasIntegral(scip, solval));
+      assert(SCIPvarGetType(consdata->resvar) == SCIP_VARTYPE_IMPLINT || SCIPisFeasIntegral(scip, solval));
 
-      if( (i == consdata->nvars) != (solval > 0.5) )
+      if( !SCIPisFeasIntegral(scip, solval) || (i == consdata->nvars) != (solval > 0.5) )
       {
          *violated = TRUE;
 
@@ -1080,7 +1082,12 @@
             SCIP_CALL( SCIPprintCons(scip, cons, NULL) );
 
             SCIPinfoMessage(scip, NULL, ";\nviolation:");
-            if( i == consdata->nvars )
+            if( !SCIPisFeasIntegral(scip, solval) )
+            {
+               SCIPinfoMessage(scip, NULL, " Resultant variable <%s> has fractional solution value %"SCIP_REAL_FORMAT"\n",
+                     SCIPvarGetName(consdata->resvar), solval);
+            }
+            else if( i == consdata->nvars )
             {
                SCIPinfoMessage(scip, NULL, " all operands are TRUE and resultant <%s> = FALSE\n",
                   SCIPvarGetName(consdata->resvar));
@@ -1351,7 +1358,7 @@
       if( SCIPvarGetLbLocal(vars[watchedvar2]) > 0.5 )
          watchedvar2 = -1;
    }
-   
+
    /* if only one watched variable is still unfixed, make it the first one */
    if( watchedvar1 == -1 )
    {
@@ -1387,7 +1394,7 @@
    if( watchedvar1 == -1 )
    {
       assert(watchedvar2 == -1);
-      
+
       SCIPdebugMessage("constraint <%s>: all operator vars fixed to 1.0 -> fix resultant <%s> to 1.0\n",
          SCIPconsGetName(cons), SCIPvarGetName(resvar));
       SCIP_CALL( SCIPinferBinvarCons(scip, resvar, TRUE, cons, (int)PROPRULE_3, &infeasible, &tightened) );
@@ -1419,7 +1426,7 @@
       if( watchedvar2 == -1 )
       {
          assert(watchedvar1 != -1);
-         
+
          SCIPdebugMessage("constraint <%s>: resultant <%s> fixed to 0.0, only one unfixed operand -> fix operand <%s> to 0.0\n",
             SCIPconsGetName(cons), SCIPvarGetName(resvar), SCIPvarGetName(vars[watchedvar1]));
          SCIP_CALL( SCIPinferBinvarCons(scip, vars[watchedvar1], FALSE, cons, (int)PROPRULE_4, &infeasible, &tightened) );
@@ -1439,7 +1446,7 @@
                (*nfixedvars)++;
             }
          }
-         
+
          return SCIP_OKAY;
       }
       else if( SCIPgetDepth(scip) <= 0 )
@@ -1453,14 +1460,14 @@
           *
           * create, add, and release the logicor constraint and remove the and constraint globally 
           */
-         
+
          SCIP_VAR** consvars;
          SCIP_CONS* lincons;
-         
+
          assert(SCIPvarGetUbGlobal(resvar) < 0.5);
-         
+
          SCIP_CALL( SCIPallocBufferArray(scip, &consvars, nvars) );
-         
+
          /* collect negated variables */
          for( i = 0; i < nvars; ++i )
          {
@@ -1487,8 +1494,10 @@
    /* switch to the new watched variables */
    SCIP_CALL( consdataSwitchWatchedvars(scip, consdata, eventhdlr, watchedvar1, watchedvar2) );
 
-   /* mark the constraint propagated */
-   consdata->propagated = TRUE;
+   /* mark the constraint propagated if we have an unfixed resultant or are not in probing, it is necessary that a fixed
+    * resulting in probing mode does not lead to a propagated constraint, because the constraint upgrade needs to be performed
+    */
+   consdata->propagated = (!SCIPinProbing(scip) || (SCIPvarGetLbLocal(consdata->resvar) < 0.5 && SCIPvarGetUbLocal(consdata->resvar) > 0.5)) ;
 
    return SCIP_OKAY;
 }
@@ -1587,7 +1596,6 @@
 
 /** perform dual presolving on and-constraints */
 static
-
 SCIP_RETCODE dualPresolve(
    SCIP*                 scip,               /**< SCIP data structure */
    SCIP_CONS**           conss,              /**< and-constraints to perform dual presolving on */
@@ -1675,6 +1683,8 @@
 
       resvar = consdata->resvar;
       assert(resvar != NULL);
+      /* a fixed resultant needs to be removed, otherwise we might fix operands to a wrong value later on */
+      assert(SCIPvarGetLbGlobal(resvar) < 0.5 && SCIPvarGetUbGlobal(resvar) > 0.5);
       assert(SCIPvarGetNLocksUp(resvar) >= 1 && SCIPvarGetNLocksDown(resvar) >= 1);
 
       if( SCIPvarGetNLocksUp(resvar) == 1 && SCIPvarGetNLocksDown(resvar) == 1 )
@@ -1789,7 +1799,7 @@
 
 	       if( *nfixedvars - oldnfixedvars == nvars )
 	       {
-		  SCIPdebugMessage("all operands are fixed in constraint <%s> are fixed (and some of them to 0), fix resultant <%s> to 0\n", SCIPconsGetName(cons), SCIPvarGetName(resvar));
+		  SCIPdebugMessage("all operands in constraint <%s> are fixed (and some of them to 0), fix resultant <%s> to 0\n", SCIPconsGetName(cons), SCIPvarGetName(resvar));
 
 		  SCIP_CALL( SCIPfixVar(scip, resvar, 0.0, &infeasible, &fixed) );
 
@@ -3898,7 +3908,7 @@
    int nfixedvars;
    int nupgdconss;
    int c;
-   
+
    conshdlrdata = SCIPconshdlrGetData(conshdlr);
    assert(conshdlrdata != NULL);
 
